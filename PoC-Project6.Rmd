---
title: "PoC-Project 6"
author: "Zifan Lin"
date: ""
output: html_document
---

## Zombie Apocalypse (BFS)

### Overview

In this mini-project, we will create a simulation of zombies and humans interacting on a grid. As in the movies, our zombies are hungry for human brains. As a result, zombies chase humans and humans flee from zombies. To keep our simulation manageable, the positions of the zombies and humans will be restricted to a grid. In our simulation, zombies are not very agile and can only move up, down, left or right in one step of the simulation. On the other hand, humans are more agile and can move in these four directions as well as the four neighboring diagonal directions. If a zombie catches a human by positioning itself in the same cell, the zombie enjoys some delicious human brains. Being a Computer Scientist, the human has plenty of brains to spare and continues to live on in our simulation.

To enhance the realism of our simulation, some of the cells in this grid will be marked as impassable and restrict zombie/human movement so that they can not move through these cells. Our task in this simulation is to implement a `Zombie` class that encapsulates the core mechanisms of this simulation and that interacts with a GUI that we have created for visualizing the simulation in CodeSkulptor. This `Zombie` class is a sub-class of the [`Grid` class](http://www.codeskulptor.org/#poc_grid.py) and inherits the `Grid` class methods. Passable cells in the grid correspond to `EMPTY` cells while `FULL` cells are impassable. Humans and zombies can only inhabit passable cells of the grid. However, several humans and zombies may inhabit the same grid cell.

This `Zombie` class also includes two lists, one for zombies and one for humans. Note that the entries in each list are cell indices of the form `(row, col)` that represent the position of zombies/humans in the grid. Each step in the simulation will either update the positions of the zombies based on the state of the grid and the position of the humans or update the positions of the humans based on the state of the grid and the position of the zombies.

### Phase One

In phase one, we will implement the basic methods for the `Zombie` class. We suggest that you start from [this template](http://www.codeskulptor.org/#poc_zombie_template.py). Note that the `Zombie` class is a subclass of the `Grid` class and inherits all of its methods.

The template contains an implementation of the `__init__` method for the `Zombie` class. The initializer takes two required arguments `grid_height` and `grid_width`. The initializer also takes three optional arguments `obstacle_list`, `zombie_list`, and `human_list` which are lists of cells that initially contain obstacles, zombies and humans, respectively. For phase one, your task is to implement the remaining seven `Zombie` methods:

- `def clear(self)`: Reset all cells in the grid to be passable and reinitialize the human and zombie lists to be empty. Remember that you can use the `clear` method from the `poc_grid.Grid` class to clear the grid of impassable cells. Examine the implementation of the `__init__` method for how to call this method.
- `def add_zombie(self, row, col)`: Add a zombie to the zombie list at the supplied row and column.
- `def num_zombies(self)`: Return the number of zombies in the zombie list.
- `def zombies(self)`: Generator that allows you to iterate over zombies in the zombie list. Here, a zombie is a tuple of the form `(row, col)` indicating the zombie's location in the grid. The generator must yield the zombies in the order they were added (even if they have moved). Remember that you can use a generator to implement this method in one or two lines of code.
- `def add_human(self, row, col)`: Add a human to the human list at the supplied row and column.
- `def num_humans(self)`: Return the number of humans in the human list.
- `def humans(self)`: Generator that allows you to iterate over humans in the human list. The generator must yield the humans in the order they were added (even if they have moved). Again, you can use a generator to implement this method in one or two lines of code.

Once you have successfully implemented these methods, you should be able to add zombies (red cells) and humans (green cells) to the simulation by toggling the button labelled `"Mouse click: ..."` and then clicking on the canvas. Cells that are occupied by both zombies and humans are purple.

### Phase Two

Phase two is the core of this mini-project. Your task will be to compute a simple approximation of the distance from each cell in the grid to the nearest zombie (or human). This distance will correspond to the length of the shortest sequence of adjacent grid cells (a path) from the cell to a zombie. This 2D array of integer distances is a distance field. The image below shows an example of two (red) zombies on a $4 \times 6$ grid and the distances from each cell in the grid to the nearest zombie. Note that in this diagram, we are using the cell's four neighbors when determining whether cells are adjacent.

Observe that the distances in this example grow in a manner strikingly similar to the order in which cells are visited during breadth-first search. This observation is not a coincidence. In fact, this distance field was computed using breadth-first search. To compute this distance field, start by recalling the English description of [breadth-first search](https://class.coursera.org/principlescomputing2-002/wiki/view?page=bfs).

```
while boundary is not empty:
    current_cell  ???  dequeue boundary
    for all neighbor_cell of current_cell:
        if neighbor_cell is not in visited:
            add neighbor_cell to visited
            enqueue neighbor_cell onto boundary
```

This description can be modified to compute a distance field during breadth-first search as follows:

- Create a new grid `visited` of the same size as the original grid and initialize its cells to be empty.
- Create a 2D list `distance_field` of the same size as the original grid and initialize each of its entries to be the product of the height times the width of the grid. (This value is larger than any possible distance.)
- Create a queue `boundary` that is a **copy** of either the zombie list or the human list. For cells in the queue, initialize `visited` to be `FULL` and `distance_field` to be zero. We recommend that you use our [`Queue class`](http://www.codeskulptor.org/#poc_queue.py).
- Finally, implement a modified version of the BFS search described above. For each `neighbor_cell` in the inner loop, check whether the cell has not been visited and is passable. If so, update the `visited` grid and the `boundary` queue as specified. In this case, also update the neighbor's distance to be the distance to `current_cell` plus one (`distance_field[current_cell[0]][current_cell[1]] + 1`).

This method computes distances in exactly the order that the wild-fire spreads. When a `neighbor_cell` is added to the queue, that neighbor's distance from a start position is just the distance to the cell `current_cell` plus the one step to the neighbor. Working from the outline above, your task in phase two is to implement the method `compute_distance_field` as specified below:

- `def compute_distance_field(self, entity_type)`: This method returns a 2D distance field computed using the four-way distance to entities of the given type (either `ZOMBIE` or `HUMAN`). Note that entries of the computed distance fields should be zero at the entities in the specified list. Non-zero distances should be computed using the shortest path computation based on breadth-first search described above. These shortest paths should avoid impassable cells.

Finally, if you are having trouble converting our English description above into Python, remember that the `update_boundary()` method from the [wild-fire demo](http://www.codeskulptor.org/#poc_wildfire_student.py) implements one step of breadth-first search.


### Phase Three

In phase three, your task is to implement two final methods that update the positions of the zombies and humans, respectively.

- `def move_humans(self, zombie_distance)`: This method updates the entries in the human list to model humans avoiding zombies. Each human either stays in its current cell or moves to a neighboring cell to maximize its distance from the zombies. Specifically, humans move to a cell that maximize their distance from the zombies according to the supplied `zombie_distance` field. In the case where several cells shared the same maximal distance, we recommend (but do not require) choosing among these cells at random.
- `def move_zombies(self, human_distance)`: This method updates the entries in the zombie list to model zombies chasing humans. Each zombie either stays in its current cell or moves to a neighboring cell to minimize its distance to the humans. Specifically, zombies moves to the cell that minimizes their distance to the humans according to the supplied `human_distance` field. In the case where several cells shared the same minimal distance, we recommend choosing (but do not require) among these cells at random.
Once you have successfully implemented the three methods in phase two and phase three, the buttons in the GUI labelled `"Zombies stalk"` and `"Humans flee"` should work. Zombies should stalk humans and humans should flee zombies. We encourage you to spend some time testing/experimenting with the simulation using our GUI. Once your code works, submit it to Owltest for grading.

### Just for fun! Observations from the simulation

At a distance, zombies are quite good at finding humans (even ones hiding in buildings) since breadth-first search always searches the interiors of buildings (provided there is an entrance). The human distance field decreases steadily and always reaches zero at a delicious human brain. Humans, on the other hand, aren't so smart while fleeing since they greedily maximize the local distance away from the nearest zombies on each step. As a result, humans often run to the nearest corner of a building and cower as the zombies approach. (Hey, this is a pretty realistic simulation!)

However, in close quarters, humans have a large advantage since they can move diagonally. Unless cornered by multiple zombies, humans can easily out-maneuver a single zombie and avoid having their brains eaten. For packs of zombies inhabiting a single cell, the strategy for breaking ties in `move_zombies` is important. When the pack has a choice between moving to two neighboring cells that minimize distance, always choosing the one cell or the other causes the zombies to stay in clumped in a single cell. Having each zombie choose between the two cells at random causes the pack to tend to disperse.

This situation arises when the pack is chasing a human that is fleeing diagonally (say down and left). There are two directions (down or left) that are available to the zombies that minimize the distance to the human. Instead of having all of the zombies move in the same direction, each zombie should choose one of the two optimal directions randomly. With the random approach, some zombies go down and some zombies go left and the pack of zombies tends to spread out. This behavior makes the zombies more likely to catch the human when he/she ends up huddled in a corner.

There are several other interesting scenarios in the simulation that we will let you explore on your own. For example, you might consider creating a "zombie-proof" building that exploits the human's ability to move diagonally between obstacles. Feel free to post interesting scenarios that you discover in the forum. So, have fun and enjoy some "Brains!"


### Submission

[Owltest page](http://codeskulptor.appspot.com/owltest?urlTests=poc.poc_zombie_tests.py&urlPylintConfig=poc.pylint_config.py&imports=%7Bpoc:(poc_grid,poc_queue,poc_zombie_gui)%7D&)

```{r test-python, eval=FALSE, engine='python'}
"""
Student portion of Zombie Apocalypse mini-project
"""

import random
import poc_grid
import poc_queue
import poc_zombie_gui

# global constants
EMPTY = 0 
FULL = 1
FOUR_WAY = 0
EIGHT_WAY = 1
OBSTACLE = "obstacle"
HUMAN = "human"
ZOMBIE = "zombie"


class Zombie(poc_grid.Grid):
    """
    Class for simulating zombie pursuit of human on grid with
    obstacles
    """

    def __init__(self, grid_height, grid_width, obstacle_list = None, 
                 zombie_list = None, human_list = None):
        """
        Create a simulation of given size with given obstacles,
        humans, and zombies
        """
        poc_grid.Grid.__init__(self, grid_height, grid_width)
        if obstacle_list != None:
            for cell in obstacle_list:
                self.set_full(cell[0], cell[1])
            self._obstacle_list = obstacle_list
        else:
            self._obstacle_list = []
        if zombie_list != None:
            self._zombie_list = list(zombie_list)
        else:
            self._zombie_list = []
        if human_list != None:
            self._human_list = list(human_list)  
        else:
            self._human_list = []
        
    def clear(self):
        """
        Set cells in obstacle grid to be empty
        Reset zombie and human lists to be empty
        """
        self._zombie_list = []
        self._human_list = []
        poc_grid.Grid.clear(self)
        
    def add_zombie(self, row, col):
        """
        Add zombie to the zombie list
        """
        self._zombie_list.append((row, col))
                
    def num_zombies(self):
        """
        Return number of zombies
        """
        return len(self._zombie_list)       
          
    def zombies(self):
        """
        Generator that yields the zombies in the order they were
        added.
        """
        for zombie in self._zombie_list:
            yield zombie

    def add_human(self, row, col):
        """
        Add human to the human list
        """
        self._human_list.append((row, col))
        
    def num_humans(self):
        """
        Return number of humans
        """
        return len(self._human_list)
    
    def humans(self):
        """
        Generator that yields the humans in the order they were added.
        """
        for human in self._human_list:
            yield human

        
    def compute_distance_field(self, entity_type):
        """
        Function computes a 2D distance field
        Distance at member of entity_queue is zero
        Shortest paths avoid obstacles and use distance_type distances
        """
        # Create a new grid visited of the same size as the original grid 
        # and initialize its cells to be empty.
        visited = poc_grid.Grid(self._grid_height, self._grid_width)
        for obstacle in self._obstacle_list:
            visited.set_full(obstacle[0], obstacle[1])
        
        # Create a 2D list of the same size as the original grid 
        # and initialize each of its entries to be the product of the height times the width of the grid.
        distance_field = [[self._grid_height * self._grid_width for dummy_c in range(self._grid_width)]
                          for dummy_r in range(self._grid_height)]
        
        # Create a queue boundary that is a copy of either the zombie list or the human list. 
        boundary = poc_queue.Queue()
        if entity_type == ZOMBIE:
            list_type = self._zombie_list
        if entity_type == HUMAN:
            list_type = self._human_list
            
        # For cells in the queue, initialize visited to be FULL and distance_field to be zero.
        for item in list_type:
            boundary.enqueue(item)
            visited.set_full(item[0], item[1])
            distance_field[item[0]][item[1]] = 0
        
        # Implement a modified version of the BFS search
        while boundary:
            cell = boundary.dequeue()
            neighbors = visited.four_neighbors(cell[0], cell[1])
            for resident in neighbors:
                if visited.is_empty(resident[0], resident[1]):
                    distance_field[resident[0]][resident[1]] = min(distance_field[resident[0]][resident[1]],
                                                                   distance_field[cell[0]][cell[1]] + 1)
                    visited.set_full(resident[0], resident[1])
                    boundary.enqueue(resident)                               

        return distance_field      
    
    def move_humans(self, zombie_distance):
        """
        Function that moves humans away from zombies, diagonal moves
        are allowed
        """
        temp_human_list = []
        for human in self.humans():
            neighbors = self.eight_neighbors(human[0], human[1])
            # store current position
            distance = [zombie_distance[human[0]][human[1]]]
            location = [human]
            
            for resident in neighbors:
                if self.is_empty(resident[0], resident[1]):
                    # and store rest of 8 other positions if not occupied
                    distance.append(zombie_distance[resident[0]][resident[1]])
                    location.append(resident)
            # find the current safest location, move there        
            safest = location[distance.index(max(distance))]          
            self.set_empty(human[0], human[1])
            temp_human_list.append(safest)
            
        self._human_list = temp_human_list

    
    def move_zombies(self, human_distance):
        """
        Function that moves zombies towards humans, no diagonal moves
        are allowed
        """
        temp_zombie_list = []
        #for zombie in self.zombies():
        for zombie in self._zombie_list:
            neighbors = self.four_neighbors(zombie[0], zombie[1])
            # store current position
            distance = [human_distance[zombie[0]][zombie[1]]]
            location = [zombie]
            
            for resident in neighbors:
                if self.is_empty(resident[0], resident[1]):
                    # and store rest of 4 other positions if not occupied
                    distance.append(human_distance[resident[0]][resident[1]])
                    location.append(resident)
            # find the current most closest location, move there  
            closest = location[distance.index(min(distance))]          
            self.set_empty(zombie[0], zombie[1])
            temp_zombie_list.append(closest)
            
        self._zombie_list = temp_zombie_list
        
# Start up gui for simulation - You will need to write some code above
# before this will work without errors

# poc_zombie_gui.run_gui(Zombie(30, 40))


```